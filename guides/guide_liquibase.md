## Liquibase

**Основные понятия:**

Liquibase - это инструмент для контроля изменений баз данных. Можно сказать, что Liquibase - это тот же git, только для баз данных. 
Всё что связанно с DDL - это про Liquibase. При помощи него Вы создаёте и изменяете таблицы и их
свойства, а Liquibase отслеживает каждое изменение и позволяет откатываться
к предыдущим состояниям.

changeSet - набор изменений, можно сказать это точка commit-а.

databasechangelog - основная таблица в которой прописаны все произошедшие 
изменения с помощью скриптов. Создаётся самим liquibase-ом в рабочей схеме
базы данных.

databasechangeloglock - тоже создаётся liquibase-ом, можно забыть про неё, 
нужна для отслеживания одновременного обращения к таблицам БД. Её использует 
liquibase, записывает туда данные во время обновлений и если произойдёт 
такая маловероятная ситуация, что два пользователя захотят обновить таблицы 
в одно и тоже время, то одному из них liquibase просто откажет. 

**Принцип действия и взаимодействия**

Главное правило, существующие файлы не править, только добавлять новые, 
liquibase сохраняет их контрольные суммы в databasechangelog, и если они 
не сойдутся, то программа не запустится.

В application.yml указана начальная точка для liquibase - это  db.changelog-master.xml.
Это главный файл где указаны основные changeSet-ы. Все файлы лежат в директории 
db.changelog

----
    <include file="новая директория/имя файла.xml" relativeToChangelogFile="true"/>

    <changeSet id="уникальный id (пример 1.1)" author="Ваше имя">
        <tagDatabase tag="Уникальный тег (пример v-1.1)"/>
    </changeSet>
----

Все новые изменения создавайте в новой директории и называйте её новой версией,
к примеру v-1.1 В этой диретории создайте файл .xml с номером версии
(пример db.changelog-v-1.1.xml) и укажите путь к нему в db.changelog-master.xml 
как показано выше. Уникальность id необходима для идентификации в таблице
databasechangelog, а уникальность тегов для возможности отката к предыдущей 
версии. 

LiquiBase не даёт ветвления у него строго поступательные коммиты(changeSet-ы), 
по которым в случае чего можно откатиться назад.

В этом файле Вы уже создаёте такие же ссылки и changeset-ы, но уже на файлы с 
sql-скриптами. эти файлы Вы помещаете в эту же директорию.
----
    <include file="имя первого файла (пример 01-create-table-searches.sql)" 
            relativeToChangelogFile="true"/>

    <changeSet id="уникальный id подверсии (пример 1.1.1)" author="Ваше имя">
        <tagDatabase tag="уникальный тег (пример v-1.1-create-table-searches)"/>
    </changeSet>

    <include file="имя второго файла (пример 02-create-table-search-results.sql" 
            relativeToChangelogFile="true"/>

    <changeSet id="уникальный id подверсии" author="Ваше имя">
        <tagDatabase tag="имя второго файла (пример v-1.1-create-table-search-results)"/>
    </changeSet>
----

На каждое действие старайтесь делать один файл с маленьким sql-скриптом.

----
CREATE TABLE searches

(

id                   BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,

from_id              BIGINT,

to_id                BIGINT,

return_date          date,

departure_date       date NOT NULL,

number_of_passengers INTEGER NOT NULL,

CONSTRAINT "searchesPK" PRIMARY KEY (id)

);

ALTER TABLE searches

ADD CONSTRAINT "FK1es2ks4yv25n78jlh6vfeiadc" FOREIGN KEY (from_id) REFERENCES destination (id);

ALTER TABLE searches

ADD CONSTRAINT "FKmr4214480arwkx4h595d1bia6" FOREIGN KEY (to_id) REFERENCES destination (id);

----

LiquiBase каждый раз начинает с начала файла мастер, там где уже есть запись в таблице
databasechangelog он только сверяет контрольные суммы, ничего не должно быть изменено.
Когда находит новые скрипты, то выполняет их и записывает в таблицу.

Если необходимо запустить заново все скрипты, то удалите обн таблицы databasechangelog и
databasechangeloglock и запустите программу.

Если нужен откат, то использовать его можно через maven plugins 
liquibase:rollback (к примеру -D liquibase.rollbackTag=v-1.0), 
но для этого в ChangeSet-ах надо прописать тег rollback, чтобы он понимал
как откатывать назад.

Пример:

----

      <changeSet информация по changeSet-у>
         ... информация по changeSet-у

         <rollback>
            <delete tableName="hero">
               <where>name = 'Савельич'</where>
            </delete>
            <delete tableName="book">
               <where>title = 'Капитанская дочка'</where>
            </delete>
            <delete tableName="hero">
               <where>first_name = 'Александр'</where>
            </delete>
         </rollback>
      </changeset>

----